Варианты целей:

1. Фиксируем функциональность (маленькую), максимизируем какой-нибудь бенчмарк.
2. Фиксируем требования по производительности, максимизируем функциональность.

Сервер:

1. Поддерживает много чатов одновременно.
   Чаты независимы.
2. В чате сервером фиксирован порядок сообщений.
3. Аутентифицирует пользователя. Пользователи глобальны для сервера.
   Простая версия: по open-text-паролю
   Сложная версия: по какому-нибудь zero-knowledge протоколу

Протокол:
1. Разные версии могли работать одновременно
   Простая версия: нешифрованное
   Сложная версия: шифрованное с сертификатами, может даже HTTP/WebSocket (чтобы был веб-клиент)
2. Разные виды сообщений(???):
   Простая версия: текстовое
   Усложнения: ответ на другое сообщение, пересланное из этого же чата/другого чата, стикеры/медиа, рандомный кубик
   Сложная версия(!!!): удаления, редактирование
3. В реальном времени
   Простая версия: pull-модель, спрашиваем текущее состояние
   Сложная версия: push-модель, активно присылаем обновления
4. Чаты личные и групповые
   Простая версия: только один вид чатов (либо личные, либо групповые) без возможности изменения
   Сложная версия: два вида чатов, зачем-то принципиально разные. Подумать(!)
5. Не будем думать про: подписи сообщений, end-to-end.
6. Серверу доверяем полностью. Клиенту доверяем на 0% (проверить fuzzing'ом).

Клиент:

1. Вариации: консольный, графический, веб-клиент
2. На разных языках

Примерный план:
1. Синхронный сервер на C++ с: несколько чатов, несколько клиентов, сохранение данных при перезапуске.
   Тут уже будет: sqlite, какой-нибудь протокол (protobuf? gRPC? но тогда проблемы с веб-клиентами)
2. Клиент для проверки + сделать доступным для зрителей
3. Клиент для бенчмарка и повалить сервер
//
4. Push-модель + редактирование сообщений
 